import { RefinementCtx } from 'zod';
export type Simplify<T> = {
    [K in keyof T]: T[K];
} & {};
export type Override<T, V> = Simplify<V & Omit<T, keyof V>>;
export type RequiredKey<T, K extends keyof T = never> = Simplify<T & {
    [L in K]-?: unknown extends T[L] ? NonNullable<unknown> | null : Exclude<T[L], undefined>;
}>;
export type DeepReadonly<T> = T extends Function ? T : T extends object ? {
    readonly [K in keyof T]: DeepReadonly<T[K]>;
} : T extends readonly (infer U)[] ? readonly DeepReadonly<U>[] : T;
export type UnReadonly<T> = T extends Function ? T : T extends object ? {
    -readonly [K in keyof T]: UnReadonly<T[K]>;
} : T extends readonly (infer U)[] ? UnReadonly<U>[] : T;
export declare const isDefined: <T>(i: T | undefined) => i is T;
export declare const preferredOrderCmp: <T>(order: readonly T[]) => (a: T, b: T) => number;
export declare function matchesAny<T extends string | number | symbol | boolean>(value: null | undefined | T | readonly T[]): (v: unknown) => v is T;
/**
 * Decorator to cache the result of a getter on a class instance.
 */
export declare const cachedGetter: <T extends object, V>(target: (this: T) => V, _context: ClassGetterDecoratorContext<T, V>) => (this: T) => V;
export declare function parseB64uJson(input: string): unknown;
/**
 * @example
 * ```ts
 * // jwtSchema will only allow base64url chars & "." (dot)
 * const jwtSchema = z.string().superRefine(jwtCharsRefinement)
 * ```
 */
export declare const jwtCharsRefinement: (data: string, ctx: RefinementCtx) => void;
/**
 * @example
 * ```ts
 * type SegmentedString3 = SegmentedString<3> // `${string}.${string}.${string}`
 * type SegmentedString4 = SegmentedString<4> // `${string}.${string}.${string}.${string}`
 * ```
 *
 * @note
 * This utility only provides one way type safety (A SegmentedString<4> can be
 * assigned to SegmentedString<3> but not vice versa). The purpose of this
 * utility is to improve DX by avoiding as many potential errors as build time.
 * DO NOT rely on this to enforce security or data integrity.
 */
type SegmentedString<C extends number, Acc extends string[] = [string]> = Acc['length'] extends C ? `${Acc[0]}` : `${Acc[0]}.${SegmentedString<C, [string, ...Acc]>}`;
/**
 * @example
 * ```ts
 * const jwtSchema = z.string().superRefine(segmentedStringRefinementFactory(3))
 * type Jwt = z.infer<typeof jwtSchema> // `${string}.${string}.${string}`
 * ```
 */
export declare const segmentedStringRefinementFactory: <C extends number>(count: C, minPartLength?: number) => (data: string, ctx: RefinementCtx) => data is SegmentedString<C>;
export {};
//# sourceMappingURL=util.d.ts.map