import { Jwks, JwksPub } from './jwks.js';
import { VerifyOptions, VerifyResult } from './jwt-verify.js';
import { JwtHeader, JwtPayload, SignedJwt } from './jwt.js';
import { Key } from './key.js';
import { DeepReadonly, Override } from './util.js';
export type JwtSignHeader = Override<JwtHeader, Pick<KeySearch, 'alg' | 'kid'>>;
export type JwtPayloadGetter<P = JwtPayload> = (header: JwtHeader, key: Key) => P | PromiseLike<P>;
export type KeySearch = {
    use?: 'sig' | 'enc';
    kid?: string | string[];
    alg?: string | string[];
};
export declare class Keyset<K extends Key = Key> implements Iterable<K> {
    /**
     * The preferred algorithms to use when signing a JWT using this keyset.
     *
     * @see {@link https://datatracker.ietf.org/doc/html/rfc7518#section-3.1}
     */
    readonly preferredSigningAlgorithms: readonly string[];
    private readonly keys;
    constructor(iterable: Iterable<K | null | undefined | false>, 
    /**
     * The preferred algorithms to use when signing a JWT using this keyset.
     *
     * @see {@link https://datatracker.ietf.org/doc/html/rfc7518#section-3.1}
     */
    preferredSigningAlgorithms?: readonly string[]);
    get size(): number;
    get signAlgorithms(): readonly string[];
    get publicJwks(): DeepReadonly<JwksPub>;
    get privateJwks(): DeepReadonly<Jwks>;
    has(kid: string): boolean;
    get(search: KeySearch): K;
    list(search: KeySearch): Generator<K>;
    findKey({ kid, alg, use }: KeySearch): [key: Key, alg: string];
    [Symbol.iterator](): IterableIterator<K>;
    createJwt({ alg: sAlg, kid: sKid, ...header }: JwtSignHeader, payload: JwtPayload | JwtPayloadGetter): Promise<SignedJwt>;
    verifyJwt<C extends string = never>(token: SignedJwt, options?: VerifyOptions<C>): Promise<VerifyResult<C> & {
        key: K;
    }>;
    toJSON(): JwksPub;
}
//# sourceMappingURL=keyset.d.ts.map