"use strict";
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Key = void 0;
const alg_js_1 = require("./alg.js");
const errors_js_1 = require("./errors.js");
const jwk_js_1 = require("./jwk.js");
const util_js_1 = require("./util.js");
const jwkSchemaReadonly = jwk_js_1.jwkSchema.readonly();
let Key = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _get_publicJwk_decorators;
    let _get_bareJwk_decorators;
    let _get_algorithms_decorators;
    return _a = class Key {
            constructor(jwk) {
                Object.defineProperty(this, "jwk", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: (__runInitializers(this, _instanceExtraInitializers), jwk)
                });
                // A key should always be used either for signing or encryption.
                if (!jwk.use)
                    throw new errors_js_1.JwkError('Missing "use" Parameter value');
            }
            get isPrivate() {
                const { jwk } = this;
                if ('d' in jwk && jwk.d !== undefined)
                    return true;
                if ('k' in jwk && jwk.k !== undefined)
                    return true;
                return false;
            }
            get isSymetric() {
                const { jwk } = this;
                if ('k' in jwk && jwk.k !== undefined)
                    return true;
                return false;
            }
            get privateJwk() {
                return this.isPrivate ? this.jwk : undefined;
            }
            get publicJwk() {
                if (this.isSymetric)
                    return undefined;
                return jwkSchemaReadonly.parse({
                    ...this.jwk,
                    d: undefined,
                    k: undefined,
                });
            }
            get bareJwk() {
                if (this.isSymetric)
                    return undefined;
                const { kty, crv, e, n, x, y } = this.jwk;
                return jwkSchemaReadonly.parse({ crv, e, kty, n, x, y });
            }
            get use() {
                return this.jwk.use;
            }
            /**
             * The (forced) algorithm to use. If not provided, the key will be usable with
             * any of the algorithms in {@link algorithms}.
             *
             * @see {@link https://datatracker.ietf.org/doc/html/rfc7518#section-3.1 | "alg" (Algorithm) Header Parameter Values for JWS}
             */
            get alg() {
                return this.jwk.alg;
            }
            get kid() {
                return this.jwk.kid;
            }
            get crv() {
                return this.jwk.crv;
            }
            /**
             * All the algorithms that this key can be used with. If `alg` is provided,
             * this set will only contain that algorithm.
             */
            get algorithms() {
                return Object.freeze(Array.from((0, alg_js_1.jwkAlgorithms)(this.jwk)));
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _get_publicJwk_decorators = [util_js_1.cachedGetter];
            _get_bareJwk_decorators = [util_js_1.cachedGetter];
            _get_algorithms_decorators = [util_js_1.cachedGetter];
            __esDecorate(_a, null, _get_publicJwk_decorators, { kind: "getter", name: "publicJwk", static: false, private: false, access: { has: obj => "publicJwk" in obj, get: obj => obj.publicJwk }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _get_bareJwk_decorators, { kind: "getter", name: "bareJwk", static: false, private: false, access: { has: obj => "bareJwk" in obj, get: obj => obj.bareJwk }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _get_algorithms_decorators, { kind: "getter", name: "algorithms", static: false, private: false, access: { has: obj => "algorithms" in obj, get: obj => obj.algorithms }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.Key = Key;
//# sourceMappingURL=key.js.map