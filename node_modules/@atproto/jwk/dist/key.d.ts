import { Jwk } from './jwk.js';
import { VerifyOptions, VerifyResult } from './jwt-verify.js';
import { JwtHeader, JwtPayload, SignedJwt } from './jwt.js';
export declare abstract class Key<J extends Jwk = Jwk> {
    protected readonly jwk: Readonly<J>;
    constructor(jwk: Readonly<J>);
    get isPrivate(): boolean;
    get isSymetric(): boolean;
    get privateJwk(): Readonly<J> | undefined;
    get publicJwk(): Readonly<Exclude<J, {
        kty: 'oct';
    }> & {
        d?: never;
    }> | undefined;
    get bareJwk(): Readonly<Jwk> | undefined;
    get use(): NonNullable<J["use"]>;
    /**
     * The (forced) algorithm to use. If not provided, the key will be usable with
     * any of the algorithms in {@link algorithms}.
     *
     * @see {@link https://datatracker.ietf.org/doc/html/rfc7518#section-3.1 | "alg" (Algorithm) Header Parameter Values for JWS}
     */
    get alg(): J["alg"] | undefined;
    get kid(): J["kid"] | undefined;
    get crv(): "P-256" | "P-384" | "P-521" | "secp256k1" | "Ed25519" | "Ed448" | undefined;
    /**
     * All the algorithms that this key can be used with. If `alg` is provided,
     * this set will only contain that algorithm.
     */
    get algorithms(): readonly string[];
    /**
     * Create a signed JWT
     */
    abstract createJwt(header: JwtHeader, payload: JwtPayload): Promise<SignedJwt>;
    /**
     * Verify the signature, headers and payload of a JWT
     *
     * @throws {JwtVerifyError} if the JWT is invalid
     */
    abstract verifyJwt<C extends string = never>(token: SignedJwt, options?: VerifyOptions<C>): Promise<VerifyResult<C>>;
}
//# sourceMappingURL=key.d.ts.map