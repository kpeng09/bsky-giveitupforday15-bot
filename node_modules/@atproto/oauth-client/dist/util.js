"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.includesSpaceSeparatedValue = exports.CustomEventTarget = exports.CustomEvent = exports.timeoutSignal = void 0;
exports.contentMime = contentMime;
exports.combineSignals = combineSignals;
// @ts-expect-error
Symbol.dispose ?? (Symbol.dispose = Symbol('@@dispose'));
/**
 * @todo (?) move to common package
 */
const timeoutSignal = (timeout, options) => {
    if (!Number.isInteger(timeout) || timeout < 0) {
        throw new TypeError('Expected a positive integer');
    }
    options?.signal?.throwIfAborted();
    const controller = new AbortController();
    const { signal } = controller;
    options?.signal?.addEventListener('abort', (reason) => controller.abort(reason), { once: true, signal });
    const timeoutId = setTimeout((err) => controller.abort(err), timeout, 
    // create Error here to keep original stack trace
    new Error('Timeout'));
    timeoutId?.unref?.(); // NodeJS only
    signal.addEventListener('abort', () => clearTimeout(timeoutId), {
        once: true,
        signal,
    });
    Object.defineProperty(signal, Symbol.dispose, {
        value: () => controller.abort(),
    });
    return signal;
};
exports.timeoutSignal = timeoutSignal;
function contentMime(headers) {
    return headers.get('content-type')?.split(';')[0].trim();
}
/**
 * Ponyfill for `CustomEvent` constructor.
 */
exports.CustomEvent = globalThis.CustomEvent ??
    (() => {
        var _CustomEvent_detail;
        class CustomEvent extends Event {
            constructor(type, options) {
                if (!arguments.length)
                    throw new TypeError('type argument is required');
                super(type, options);
                _CustomEvent_detail.set(this, void 0);
                __classPrivateFieldSet(this, _CustomEvent_detail, options?.detail ?? null, "f");
            }
            get detail() {
                return __classPrivateFieldGet(this, _CustomEvent_detail, "f");
            }
        }
        _CustomEvent_detail = new WeakMap();
        Object.defineProperties(CustomEvent.prototype, {
            [Symbol.toStringTag]: {
                writable: false,
                enumerable: false,
                configurable: true,
                value: 'CustomEvent',
            },
            detail: {
                enumerable: true,
            },
        });
        return CustomEvent;
    })();
class CustomEventTarget {
    constructor() {
        Object.defineProperty(this, "eventTarget", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new EventTarget()
        });
    }
    addEventListener(type, callback, options) {
        this.eventTarget.addEventListener(type, callback, options);
    }
    removeEventListener(type, callback, options) {
        this.eventTarget.removeEventListener(type, callback, options);
    }
    dispatchCustomEvent(type, detail, init) {
        return this.eventTarget.dispatchEvent(new exports.CustomEvent(type, { ...init, detail }));
    }
}
exports.CustomEventTarget = CustomEventTarget;
const includesSpaceSeparatedValue = (input, value) => {
    if (value.length === 0)
        throw new TypeError('Value cannot be empty');
    if (value.includes(' '))
        throw new TypeError('Value cannot contain spaces');
    // Optimized version of:
    // return input.split(' ').includes(value)
    const inputLength = input.length;
    const valueLength = value.length;
    if (inputLength < valueLength)
        return false;
    let idx = input.indexOf(value);
    let idxEnd;
    while (idx !== -1) {
        idxEnd = idx + valueLength;
        if (
        // at beginning or preceded by space
        (idx === 0 || input[idx - 1] === ' ') &&
            // at end or followed by space
            (idxEnd === inputLength || input[idxEnd] === ' ')) {
            return true;
        }
        idx = input.indexOf(value, idxEnd + 1);
    }
    return false;
};
exports.includesSpaceSeparatedValue = includesSpaceSeparatedValue;
function combineSignals(signals) {
    const controller = new AbortController();
    const onAbort = function (_event) {
        const reason = new Error('This operation was aborted', {
            cause: this.reason,
        });
        controller.abort(reason);
    };
    for (const sig of signals) {
        if (!sig)
            continue;
        if (sig.aborted) {
            // Remove "abort" listener that was added to sig in previous iterations
            controller.abort();
            throw new Error('One of the signals is already aborted', {
                cause: sig.reason,
            });
        }
        sig.addEventListener('abort', onAbort, { signal: controller.signal });
    }
    controller[Symbol.dispose] = () => {
        const reason = new Error('AbortController was disposed');
        controller.abort(reason);
    };
    return controller;
}
//# sourceMappingURL=util.js.map