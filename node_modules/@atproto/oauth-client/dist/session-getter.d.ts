import { AtprotoDid } from '@atproto/did';
import { Key } from '@atproto/jwk';
import { CachedGetter, GetCachedOptions, SimpleStore } from '@atproto-labs/simple-store';
import { TokenInvalidError } from './errors/token-invalid-error.js';
import { TokenRefreshError } from './errors/token-refresh-error.js';
import { TokenRevokedError } from './errors/token-revoked-error.js';
import { TokenSet } from './oauth-server-agent.js';
import { OAuthServerFactory } from './oauth-server-factory.js';
import { Runtime } from './runtime.js';
export type Session = {
    dpopKey: Key;
    tokenSet: TokenSet;
};
export type SessionStore = SimpleStore<string, Session>;
export type SessionEventMap = {
    updated: {
        sub: string;
    } & Session;
    deleted: {
        sub: string;
        cause: TokenRefreshError | TokenRevokedError | TokenInvalidError | unknown;
    };
};
export type SessionEventListener<T extends keyof SessionEventMap = keyof SessionEventMap> = (event: CustomEvent<SessionEventMap[T]>) => void;
/**
 * There are several advantages to wrapping the sessionStore in a (single)
 * CachedGetter, the main of which is that the cached getter will ensure that at
 * most one fresh call is ever being made. Another advantage, is that it
 * contains the logic for reading from the cache which, if the cache is based on
 * localStorage/indexedDB, will sync across multiple tabs (for a given sub).
 */
export declare class SessionGetter extends CachedGetter<AtprotoDid, Session> {
    private readonly runtime;
    private readonly eventTarget;
    constructor(sessionStore: SessionStore, serverFactory: OAuthServerFactory, runtime: Runtime);
    addEventListener<T extends keyof SessionEventMap>(type: T, callback: SessionEventListener<T>, options?: AddEventListenerOptions | boolean): void;
    removeEventListener<T extends keyof SessionEventMap>(type: T, callback: SessionEventListener<T>, options?: EventListenerOptions | boolean): void;
    dispatchEvent<T extends keyof SessionEventMap>(type: T, detail: SessionEventMap[T]): boolean;
    setStored(sub: string, session: Session): Promise<void>;
    delStored(sub: AtprotoDid, cause?: unknown): Promise<void>;
    /**
     * @param refresh When `true`, the credentials will be refreshed even if they
     * are not expired. When `false`, the credentials will not be refreshed even
     * if they are expired. When `undefined`, the credentials will be refreshed
     * if, and only if, they are (about to be) expired. Defaults to `undefined`.
     */
    getSession(sub: AtprotoDid, refresh?: boolean): Promise<Session>;
    get(sub: AtprotoDid, options?: GetCachedOptions): Promise<Session>;
}
//# sourceMappingURL=session-getter.d.ts.map