"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.oauthClientIdDiscoverableSchema = void 0;
exports.isOAuthClientIdDiscoverable = isOAuthClientIdDiscoverable;
exports.assertOAuthDiscoverableClientId = assertOAuthDiscoverableClientId;
exports.parseOAuthDiscoverableClientId = parseOAuthDiscoverableClientId;
const zod_1 = require("zod");
const oauth_client_id_js_1 = require("./oauth-client-id.js");
const uri_js_1 = require("./uri.js");
const util_js_1 = require("./util.js");
/**
 * @see {@link https://drafts.aaronpk.com/draft-parecki-oauth-client-id-metadata-document/draft-parecki-oauth-client-id-metadata-document.html}
 */
exports.oauthClientIdDiscoverableSchema = zod_1.z
    .intersection(oauth_client_id_js_1.oauthClientIdSchema, uri_js_1.httpsUriSchema)
    .superRefine((value, ctx) => {
    const url = new URL(value);
    if (url.username || url.password) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID must not contain credentials',
        });
        return false;
    }
    if (url.hash) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID must not contain a fragment',
        });
        return false;
    }
    if (url.pathname === '/') {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID must contain a path component (e.g. "/client-metadata.json")',
        });
        return false;
    }
    if (url.pathname.endsWith('/')) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID path must not end with a trailing slash',
        });
        return false;
    }
    if ((0, util_js_1.isHostnameIP)(url.hostname)) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: 'ClientID hostname must not be an IP address',
        });
        return false;
    }
    // URL constructor normalizes the URL, so we extract the path manually to
    // avoid normalization, then compare it to the normalized path to ensure
    // that the URL does not contain path traversal or other unexpected characters
    if ((0, util_js_1.extractUrlPath)(value) !== url.pathname) {
        ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: `ClientID must be in canonical form ("${url.href}", got "${value}")`,
        });
        return false;
    }
    return true;
});
function isOAuthClientIdDiscoverable(clientId) {
    return exports.oauthClientIdDiscoverableSchema.safeParse(clientId).success;
}
function assertOAuthDiscoverableClientId(value) {
    void exports.oauthClientIdDiscoverableSchema.parse(value);
}
function parseOAuthDiscoverableClientId(clientId) {
    return new URL(exports.oauthClientIdDiscoverableSchema.parse(clientId));
}
//# sourceMappingURL=oauth-client-id-discoverable.js.map