"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.oauthClientIdLoopbackSchema = void 0;
exports.isOAuthClientIdLoopback = isOAuthClientIdLoopback;
exports.assertOAuthLoopbackClientId = assertOAuthLoopbackClientId;
exports.parseOAuthLoopbackClientId = parseOAuthLoopbackClientId;
const zod_1 = require("zod");
const oauth_client_id_js_1 = require("./oauth-client-id.js");
const oauth_redirect_uri_js_1 = require("./oauth-redirect-uri.js");
const oauth_scope_js_1 = require("./oauth-scope.js");
const PREFIX = 'http://localhost';
exports.oauthClientIdLoopbackSchema = oauth_client_id_js_1.oauthClientIdSchema.superRefine((value, ctx) => {
    try {
        assertOAuthLoopbackClientId(value);
        return true;
    }
    catch (error) {
        ctx.addIssue({
            code: zod_1.ZodIssueCode.custom,
            message: error instanceof TypeError
                ? error.message
                : 'Invalid loopback client ID',
        });
        return false;
    }
});
function isOAuthClientIdLoopback(clientId) {
    try {
        parseOAuthLoopbackClientId(clientId);
        return true;
    }
    catch {
        return false;
    }
}
function assertOAuthLoopbackClientId(clientId) {
    void parseOAuthLoopbackClientId(clientId);
}
// @TODO: should we turn this into a zod schema? (more coherent error with other
// validation functions)
function parseOAuthLoopbackClientId(clientId) {
    if (!clientId.startsWith(PREFIX)) {
        throw new TypeError(`Loopback ClientID must start with "${PREFIX}"`);
    }
    else if (clientId.includes('#', PREFIX.length)) {
        throw new TypeError('Loopback ClientID must not contain a hash component');
    }
    const queryStringIdx = clientId.length > PREFIX.length && clientId[PREFIX.length] === '/'
        ? PREFIX.length + 1
        : PREFIX.length;
    if (clientId.length === queryStringIdx) {
        return {}; // no query string to parse
    }
    if (clientId[queryStringIdx] !== '?') {
        throw new TypeError('Loopback ClientID must not contain a path component');
    }
    const searchParams = new URLSearchParams(clientId.slice(queryStringIdx + 1));
    for (const name of searchParams.keys()) {
        if (name !== 'redirect_uri' && name !== 'scope') {
            throw new TypeError(`Invalid query parameter "${name}" in client ID`);
        }
    }
    const scope = searchParams.get('scope') ?? undefined;
    if (scope != null) {
        if (searchParams.getAll('scope').length > 1) {
            throw new TypeError('Loopback ClientID must contain at most one scope query parameter');
        }
        else if (!oauth_scope_js_1.oauthScopeSchema.safeParse(scope).success) {
            throw new TypeError('Invalid scope query parameter in client ID');
        }
    }
    const redirect_uris = searchParams.has('redirect_uri')
        ? searchParams
            .getAll('redirect_uri')
            .map((value) => oauth_redirect_uri_js_1.oauthLoopbackRedirectURISchema.parse(value))
        : undefined;
    return {
        scope,
        redirect_uris,
    };
}
//# sourceMappingURL=oauth-client-id-loopback.js.map