"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AtprotoDohHandleResolver = void 0;
const atproto_handle_resolver_js_1 = require("./atproto-handle-resolver.js");
class AtprotoDohHandleResolver extends atproto_handle_resolver_js_1.AtprotoHandleResolver {
    constructor(options) {
        super({
            ...options,
            resolveTxt: dohResolveTxtFactory(options),
            resolveTxtFallback: undefined,
        });
    }
}
exports.AtprotoDohHandleResolver = AtprotoDohHandleResolver;
/**
 * Resolver for DNS-over-HTTPS (DoH) handles. Only works with servers supporting
 * Google Flavoured "application/dns-json" queries.
 *
 * @see {@link https://developers.google.com/speed/public-dns/docs/doh/json}
 * @see {@link https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/make-api-requests/dns-json/}
 * @todo Add support for DoH using application/dns-message (?)
 */
function dohResolveTxtFactory({ dohEndpoint, fetch = globalThis.fetch, }) {
    return async (hostname) => {
        const url = new URL(dohEndpoint);
        url.searchParams.set('type', 'TXT');
        url.searchParams.set('name', hostname);
        const response = await fetch(url, {
            method: 'GET',
            headers: { accept: 'application/dns-json' },
            redirect: 'follow',
        });
        try {
            const contentType = response.headers.get('content-type')?.trim();
            if (!response.ok) {
                const message = contentType?.startsWith('text/plain')
                    ? await response.text()
                    : `Failed to resolve ${hostname}`;
                throw new TypeError(message);
            }
            else if (contentType?.match(/application\/(dns-)?json/i) == null) {
                throw new TypeError('Unexpected response from DoH server');
            }
            const result = asResult(await response.json());
            return result.Answer?.filter(isAnswerTxt).map(extractTxtData) ?? null;
        }
        finally {
            // Make sure to always cancel the response body as some engines (Node ðŸ‘€)
            // do not do this automatically.
            // https://undici.nodejs.org/#/?id=garbage-collection
            if (response.bodyUsed === false) {
                // Handle rejection asynchronously
                void response.body?.cancel().catch(onCancelError);
            }
        }
    };
}
function onCancelError(err) {
    if (!(err instanceof DOMException) || err.name !== 'AbortError') {
        console.error('An error occurred while cancelling the response body:', err);
    }
}
function isResult(result) {
    if (typeof result !== 'object' || result === null)
        return false;
    if (!('Status' in result) || typeof result.Status !== 'number')
        return false;
    if ('Answer' in result && !isArrayOf(result.Answer, isAnswer))
        return false;
    return true;
}
function asResult(result) {
    if (isResult(result))
        return result;
    throw new TypeError('Invalid DoH response');
}
function isArrayOf(value, predicate) {
    return Array.isArray(value) && value.every(predicate);
}
function isAnswer(answer) {
    return (typeof answer === 'object' &&
        answer !== null &&
        'name' in answer &&
        typeof answer.name === 'string' &&
        'type' in answer &&
        typeof answer.type === 'number' &&
        'data' in answer &&
        typeof answer.data === 'string' &&
        'TTL' in answer &&
        typeof answer.TTL === 'number');
}
function isAnswerTxt(answer) {
    return answer.type === 16;
}
function extractTxtData(answer) {
    return answer.data.replace(/^"|"$/g, '').replace(/\\"/g, '"');
}
//# sourceMappingURL=atproto-doh-handle-resolver.js.map