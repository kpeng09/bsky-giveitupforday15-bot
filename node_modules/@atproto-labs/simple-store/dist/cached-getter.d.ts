import { Awaitable, Key, SimpleStore, Value } from './simple-store.js';
export type GetCachedOptions = {
    signal?: AbortSignal;
    /**
     * Do not use the cache to get the value. Always get a new value from the
     * getter function.
     *
     * @default false
     */
    noCache?: boolean;
    /**
     * When getting a value from the cache, allow the value to be returned even if
     * it is stale.
     *
     * Has no effect if the `isStale` option was not provided to the CachedGetter.
     *
     * @default true // If the CachedGetter has an isStale option
     * @default false // If no isStale option was provided to the CachedGetter
     */
    allowStale?: boolean;
};
export type Getter<K, V> = (key: K, options: undefined | GetCachedOptions, storedValue: undefined | V) => Awaitable<V>;
export type CachedGetterOptions<K, V> = {
    isStale?: (key: K, value: V) => boolean | PromiseLike<boolean>;
    onStoreError?: (err: unknown, key: K, value: V) => void | PromiseLike<void>;
    deleteOnError?: (err: unknown, key: K, value: V) => boolean | PromiseLike<boolean>;
};
/**
 * Wrapper utility that uses a store to speed up the retrieval of values from an
 * (expensive) getter function.
 */
export declare class CachedGetter<K extends Key = string, V extends Value = Value> {
    readonly getter: Getter<K, V>;
    readonly store: SimpleStore<K, V>;
    readonly options?: Readonly<CachedGetterOptions<K, V>> | undefined;
    private pending;
    constructor(getter: Getter<K, V>, store: SimpleStore<K, V>, options?: Readonly<CachedGetterOptions<K, V>> | undefined);
    get(key: K, options?: GetCachedOptions): Promise<V>;
    bind(key: K): (options?: GetCachedOptions) => Promise<V>;
    getStored(key: K, options?: GetCachedOptions): Promise<V | undefined>;
    setStored(key: K, value: V): Promise<void>;
    delStored(key: K, _cause?: unknown): Promise<void>;
}
//# sourceMappingURL=cached-getter.d.ts.map