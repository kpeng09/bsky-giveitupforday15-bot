"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DidResolverBase = void 0;
const zod_1 = require("zod");
const did_1 = require("@atproto/did");
const fetch_1 = require("@atproto-labs/fetch");
class DidResolverBase {
    constructor(methods) {
        Object.defineProperty(this, "methods", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.methods = new Map(Object.entries(methods));
    }
    async resolve(did, options) {
        options?.signal?.throwIfAborted();
        const method = (0, did_1.extractDidMethod)(did);
        const resolver = this.methods.get(method);
        if (!resolver) {
            throw new did_1.DidError(did, `Unsupported DID method`, 'did-method-invalid', 400);
        }
        try {
            const document = await resolver.resolve(did, options);
            if (document.id !== did) {
                throw new did_1.DidError(did, `DID document id (${document.id}) does not match DID`, 'did-document-id-mismatch', 400);
            }
            return document;
        }
        catch (err) {
            if (err instanceof fetch_1.FetchResponseError) {
                const status = err.response.status >= 500 ? 502 : err.response.status;
                throw new did_1.DidError(did, err.message, 'did-fetch-error', status, err);
            }
            if (err instanceof fetch_1.FetchError) {
                throw new did_1.DidError(did, err.message, 'did-fetch-error', 400, err);
            }
            if (err instanceof zod_1.ZodError) {
                throw new did_1.DidError(did, err.message, 'did-document-format-error', 503, err);
            }
            throw did_1.DidError.from(err, did);
        }
    }
}
exports.DidResolverBase = DidResolverBase;
//# sourceMappingURL=did-resolver-base.js.map