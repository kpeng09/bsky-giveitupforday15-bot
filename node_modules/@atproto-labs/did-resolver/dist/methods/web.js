"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DidWebMethod = void 0;
exports.buildDidWebDocumentUrl = buildDidWebDocumentUrl;
const did_1 = require("@atproto/did");
const fetch_1 = require("@atproto-labs/fetch");
const pipe_1 = require("@atproto-labs/pipe");
const fetchSuccessHandler = (0, pipe_1.pipe)((0, fetch_1.fetchOkProcessor)(), (0, fetch_1.fetchJsonProcessor)(/^application\/(did\+ld\+)?json$/), (0, fetch_1.fetchJsonZodProcessor)(did_1.didDocumentValidator));
class DidWebMethod {
    constructor({ fetch = globalThis.fetch, allowHttp = true, } = {}) {
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "allowHttp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.fetch = (0, fetch_1.bindFetch)(fetch);
        this.allowHttp = allowHttp;
    }
    async resolve(did, options) {
        const didDocumentUrl = buildDidWebDocumentUrl(did);
        if (!this.allowHttp && didDocumentUrl.protocol === 'http:') {
            throw new did_1.DidError(did, 'Resolution of "http" did:web is not allowed', 'did-web-http-not-allowed');
        }
        // Note we do not explicitly check for "localhost" here. Instead, we rely on
        // the injected 'fetch' function to handle the URL. If the URL is
        // "localhost", or resolves to a private IP address, the fetch function is
        // responsible for handling it.
        return this.fetch(didDocumentUrl, {
            redirect: 'error',
            headers: { accept: 'application/did+ld+json,application/json' },
            signal: options?.signal,
        }).then(fetchSuccessHandler);
    }
}
exports.DidWebMethod = DidWebMethod;
/**
 * @see {@link https://datatracker.ietf.org/doc/html/rfc8615}
 * @see {@link https://w3c-ccg.github.io/did-method-web/#create-register}
 */
function buildDidWebDocumentUrl(did) {
    const url = (0, did_1.didWebToUrl)(did); // Will throw if the DID is invalid
    // Note: DID cannot end with an `:`, so they cannot end with a `/`. This is
    // true unless when there is no path at all, in which case the URL constructor
    // will set the pathname to `/`.
    // https://w3c-ccg.github.io/did-method-web/#read-resolve
    if (url.pathname === '/') {
        return new URL(`/.well-known/did.json`, url);
    }
    else {
        return new URL(`${url.pathname}/did.json`, url);
    }
}
//# sourceMappingURL=web.js.map